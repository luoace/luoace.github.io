<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luoace.github.io","root":"/","scheme":"Mist","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="你好呀 十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房">
<meta property="og:type" content="article">
<meta property="og:title" content="helloworld1">
<meta property="og:url" content="https://luoace.github.io/2020/02/17/helloworld1/index.html">
<meta property="og:site_name" content="LCX">
<meta property="og:description" content="你好呀 十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luoace.github.io/2020/02/17/helloworld1/img/heart.jpg">
<meta property="article:published_time" content="2020-02-17T04:08:25.000Z">
<meta property="article:modified_time" content="2020-02-17T12:30:35.625Z">
<meta property="article:author" content="新之言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luoace.github.io/2020/02/17/helloworld1/img/heart.jpg">

<link rel="canonical" href="https://luoace.github.io/2020/02/17/helloworld1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>helloworld1 | LCX</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/luoace" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LCX</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">新之言</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home  //首页"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user //关于"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags  //标签"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th  //分类"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive //归档"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar //时间表"></i>日程表</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luoace.github.io/2020/02/17/helloworld1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang1.png">
      <meta itemprop="name" content="新之言">
      <meta itemprop="description" content="求而不得，往往不求而得">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LCX">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          helloworld1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-17 12:08:25 / 修改时间：20:30:35" itemprop="dateCreated datePublished" datetime="2020-02-17T12:08:25+08:00">2020-02-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="你好呀"><a href="#你好呀" class="headerlink" title="你好呀"></a>你好呀</h2><hr>
<p>十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·十分士大夫士大夫是降低分数的机房建设的·<br>Moorez<br>首页<br>分类<br>关于<br>归档<br>标签<br>搜索<br>IVWEB 玩转 WASM 系列-WEBGL YUV渲染图像实践<br>发表于 2019-12-14   |   分类于 前端   |   热度40 ℃<br>| 字数统计 5,369 字 | 阅读时长 22 分钟<br>最近团队在用 WASM + FFmpeg 打造一个 WEB 播放器。我们是通过写 C 语言用 FFmpeg 解码视频，通过编译 C 语言转 WASM 运行在浏览器上与 JavaScript 进行通信。默认 FFmpeg 去解码出来的数据是 yuv，而 canvas 只支持渲染 rgb，那么此时我们有两种方法处理这个yuv，第一个使用 FFmpeg 暴露的方法将 yuv 直接转成 rgb 然后给 canvas 进行渲染，第二个使用 webgl 将 yuv 转 rgb ，在 canvas 上渲染。第一个好处是写法很简单，只需 FFmpeg 暴露的方法将 yuv 直接转成 rgb ，缺点呢就是会耗费一定的cpu，第二个好处是会利用 gpu 进行加速，缺点是写法比较繁琐，而且需要熟悉 WEBGL 。考虑到为了减少 cpu 的占用，利用 gpu 进行并行加速，我们采用了第二种方法。</p>
<p>在讲 YUV 之前，我们先来看下 YUV 是怎么获取到的：<br>实现播放器必定要经过的步骤<br>由于我们是写播放器，实现一个播放器的步骤必定会经过以下这几个步骤：</p>
<p>将视频的文件比如 mp4，avi，flv等等，mp4，avi，flv 相当于是一个容器，里面包含一些信息，比如压缩的视频，压缩的音频等等， 进行解复用，从容器里面提取出压缩的视频以及音频，压缩的视频一般是 H265、H264 格式或者其他格式，压缩的音频一般是 aac或者 mp3。<br>分别在压缩的视频和压缩的音频进行解码，得到原始的视频和音频，原始的音频数据一般是pcm ，而原始的视频数据一般是 yuv 或者 rgb。<br>然后进行音视频的同步。<br>可以看到解码压缩的视频数据之后，一般就会得到 yuv。<br>YUV<br>YUV 是什么<br>对于前端开发者来说，YUV 其实有点陌生，对于搞过音视频开发的一般会接触到这个，简单来说，YUV 和我们熟悉的 RGB 差不多，都是颜色编码方式，只不过它们的三个字母代表的意义与 RGB 不同，YUV 的 “Y” 表示明亮度（Luminance或Luma），也就是灰度值；而 ”U” 和 ”V” 表示的则是色度（Chrominance或Chroma），描述影像色彩及饱和度，用于指定像素的颜色。</p>
<p>为了让大家对 YUV 有更加直观的感受，我们来看下，Y，U，V 单独显示分别是什么样子，这里使用了 FFmpeg 命令将一张火影忍者的宇智波鼬图片转成YUV420P：</p>
<p>ffmpeg -i frame.jpg -s 352x288 -pix_fmt yuv420p test.yuv<br>在 GLYUVPlay软件上打开 test.yuv，显示原图：<br>原图<br>Y分量单独显示：<br>Y<br>U分量单独显示：<br>U<br>V 分量单独显示：<br>V<br>由上面可以发现，Y 单独显示的时候是可以显示完整的图像的，只不过图片是灰色的。而U，V则代表的是色度，一个偏蓝，一个偏红。</p>
<p>使用YUV 的好处<br>由刚才看到的那样，Y 单独显示是黑白图像，因此YUV格式由彩色转黑白很简单，可以兼容老式黑白电视，这一特性用在于电视信号上。<br>YUV的数据尺寸一般都比RGB格式小，可以节约传输的带宽。（但如果用YUV444的话，和RGB24一样都是24位）<br>YUV 采样<br>常见的YUV的采样有YUV444，YUV422，YUV420：</p>
<p>注：黑点表示采样该像素点的Y分量，空心圆圈表示采用该像素点的UV分量。</p>
<p>YUV 4:4:4采样，每一个Y对应一组UV分量。<br>YUV 4:2:2采样，每两个Y共用一组UV分量。<br>YUV 4:2:0采样，每四个Y共用一组UV分量。<br>YUV 存储方式<br>YUV的存储格式有两类：packed（打包）和 planar（平面）：</p>
<p>packed 的YUV格式，每个像素点的Y,U,V是连续交错存储的。<br>planar 的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。<br>举个例子，对于 planar 模式，YUV 可以这么存 YYYYUUVV，对于 packed 模式，YUV 可以这么存YUYVYUYV。</p>
<p>YUV 格式一般有多种，YUV420SP、YUV420P、YUV422P，YUV422SP等，我们来看下比较常见的格式：</p>
<p>YUV420P（每四个 Y 会共用一组 UV 分量）：</p>
<p>YUV420SP（packed，每四个 Y 会共用一组 UV 分量，和YUV420P不同的是，YUV420SP存储的时候 U，V 是交错存储）：</p>
<p>YUV422P（planar，每两个 Y 共用一组 UV 分量，所以 U和 V 会比 YUV420P U 和 V 各多加一行）：</p>
<p>YUV422SP（packed，每两个 Y 共用一组 UV 分量）：</p>
<p>其中YUV420P和YUV420SP根据U、V的顺序，又可分出2种格式：</p>
<p>YUV420P：U前V后即YUV420P，也叫I420，V前U后，叫YV12。</p>
<p>YUV420SP：U前V后叫NV12，V前U后叫NV21。</p>
<p>数据排列如下:</p>
<p>I420: YYYYYYYY UU VV =&gt;YUV420P<br>YV12: YYYYYYYY VV UU =&gt;YUV420P<br>NV12: YYYYYYYY UV UV =&gt;YUV420SP<br>NV21: YYYYYYYY VU VU =&gt;YUV420SP<br>至于为啥会有这么多格式，经过大量搜索发现原因是为了适配不同的电视广播制式和设备系统，比如 ios 下只有这一种模式NV12，安卓的模式是 NV21，比如 YUV411、YUV420格式多见于数码摄像机数据中，前者用于NTSC制，后者用于 PAL制。至于电视广播制式的介绍我们可以看下这篇文章【标准】NTSC、PAL、SECAM三大制式简介</p>
<p>YUV 计算方法<br>以YUV420P存储一张1080 x 1280图片为例子，其存储大小为 ((1080 x 1280 x 3) &gt;&gt; 1) 个字节，这个是怎么算出来的？我们来看下面这张图：</p>
<p>以 Y420P 存储那么 Y 占的大小为 W x H = 1080x1280，U 为(W/2) * (H/2)= (W<em>H)/4 = (1080x1280)/4，同理 V为<br>(W</em>H)/4 = (1080x1280)/4，因此一张图为 Y+U+V = (1080x1280)*3/2。<br>由于三个部分内部均是行优先存储，三个部分之间是Y,U,V 顺序存储，那么YUV的存储位置如下（PS：后面会用到）：</p>
<p>Y：0 到 1080<em>1280<br>U：1080</em>1280 到 (1080<em>1280)</em>5/4<br>V：(1080<em>1280)</em>5/4 到 (1080<em>1280)</em>3/2<br>WEBGL<br>WEBGL 是什么<br>简单来说，WebGL是一项用来在网页上绘制和渲染复杂3D图形，并允许用户与之交互的技术。</p>
<p>WEBGL 组成<br>在 webgl 世界中，能绘制的基本图形元素只有点、线、三角形，每个图像都是由大大小小的三角形组成，如下图，无论是多么复杂的图形，其基本组成部分都是由三角形组成。</p>
<p>图来源于网络</p>
<p>着色器<br>着色器是在GPU上运行的程序，是用OpenGL ES着色语言编写的，有点类似 c 语言：</p>
<p>具体的语法可以参考着色器语言 GLSL (opengl-shader-language)入门大全，这里不在多加赘述。</p>
<p>在 WEBGL 中想要绘制图形就必须要有两个着色器：</p>
<p>顶点着色器<br>片元着色器<br>其中顶点着色器的主要功能就是用来处理顶点的，而片元着色器则是用来处理由光栅化阶段生成的每个片元（PS：片元可以理解为像素），最后计算出每个像素的颜色。</p>
<p>WEBGL 绘制流程<br>一、提供顶点坐标<br>因为程序很傻，不知道图形的各个顶点，需要我们自己去提供，顶点坐标可以是自己手动写或者是由软件导出：</p>
<p>在这个图中，我们把顶点写入到缓冲区里，缓冲区对象是WebGL系统中的一块内存区域，我们可以一次性地向缓冲区对象中填充大量的顶点数据，然后将这些数据保存在其中，供顶点着色器使用。接着我们创建并编译顶点着色器和片元着色器，并用 program 连接两个着色器，并使用。举个例子简单理解下为什么要这样做，我们可以理解成创建Fragment 元素： let f = document.createDocumentFragment()，<br>所有的着色器创建并编译后会处在一种游离的状态，我们需要将他们联系起来，并使用（可以理解成 document.body.appendChild(f)，添加到 body，dom 元素才能被看到，也就是联系并使用）。<br>接着我们还需要将缓冲区与顶点着色器进行连接，这样才能生效。</p>
<p>二、图元装配<br>我们提供顶点之后，GPU根据我们提供的顶点数量，会挨个执行顶点着色器程序，生成顶点最终的坐标，将图形装配起来。可以理解成制作风筝，就需要将风筝骨架先搭建起来，图元装配就是在这一阶段。</p>
<p>三、光栅化<br>这一阶段就好比是制作风筝，搭建好风筝骨架后，但是此时却不能飞起来，因为里面都是空的，需要为骨架添加布料。而光栅化就是在这一阶段，将图元装配好的几何图形转成片元（PS: 片元可以理解成像素）。</p>
<p>四、着色与渲染</p>
<p>着色这一阶段就好比风筝布料搭建完成，但是此时并没有什么图案，需要绘制图案，让风筝更加好看，也就是光栅化后的图形此时并没有颜色，需要经过片元着色器处理，逐片元进行上色并写到颜色缓冲区里，最后在浏览器才能显示有图像的几何图形。</p>
<p>总结<br>WEBGL 绘制流程可以归纳为以下几点：</p>
<p>提供顶点坐标（需要我们提供）<br>图元装配（按图元类型组装成图形）<br>光栅化（将图元装配好的图形，生成像素点）<br>提供颜色值（可以动态计算，像素着色）<br>通过 canvas 绘制在浏览器上。</p>
<p>WEBGL YUV 绘制图像思路<br>由于每个视频帧的图像都不太一样，我们肯定不可能知道那么多顶点，那么我们怎么将视频帧的图像用 webgl 画出来呢？这里使用了一个技巧—纹理映射。简单来说就是将一张图像贴在一个几何图形表面，使几何图形看起来像是有图像的几何图形，也就是将纹理坐标和 webgl 系统坐标进行一一对应：</p>
<p>如上图，上面那个是纹理坐标，分为 s 和 t 坐标（或者叫 uv 坐标），值的范围在【0，1】之间，值和图像大小、分辨率无关。下面那张图是webgl坐标系统，是一个三维的坐标系统，这里声明了四个顶点，用两个三角形组装成一个长方形，然后将纹理坐标的顶点与 webgl 坐标系进行一一对应，最终传给片元着色器，片元着色器提取图片的一个个纹素颜色，输出在颜色缓冲区里，最终绘制在浏览器里（PS：纹素你可以理解为组成纹理图像的像素）。但是如果按图上进行一一对应的话，成像会是反的，因为 canvas 的图像坐标，默认（0，0）是在左上角：</p>
<p>而纹理坐标则是在左下角，所以绘制时成像就会倒立，解决方法有两种：</p>
<p>对纹理图像进行 Y 轴翻转，webgl 提供了api：</p>
<p>// 1代表对纹理图像进行y轴反转<br>gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);<br>纹理坐标和 webgl 坐标映射进行倒转，举个栗子🌰，如上图所示，本来的纹理坐标（0.0，1.0）对应的是webgl 坐标（-1.0，1.0，0.0），（0.0，0.0）对应的是（-1.0，-1.0，0.0），那么我们倒转过来，（0.0，1.0）对应的是（-1.0，-1.0，0.0），而（0.0，0.0）对应的是（-1.0，1.0，0.0），这样在浏览器成像就不会是反的。</p>
<p>详细步骤</p>
<p>着色器部分</p>
<p>// 顶点着色器vertexShader<br>attribute lowp vec4 a_vertexPosition; // 通过 js 传递顶点坐标<br>attribute vec2 a_texturePosition; // 通过 js 传递纹理坐标<br>varying vec2 v_texCoord; // 传递纹理坐标给片元着色器<br>void main(){<br>    gl_Position=a_vertexPosition;// 设置顶点坐标<br>    v_texCoord=a_texturePosition;// 设置纹理坐标<br>}<br>// 片元着色器fragmentShader<br>precision lowp float;// lowp代表计算精度，考虑节约性能使用了最低精度<br>uniform sampler2D samplerY;// sampler2D是取样器类型，图片纹理最终存储在该类型对象中<br>uniform sampler2D samplerU;// sampler2D是取样器类型，图片纹理最终存储在该类型对象中<br>uniform sampler2D samplerV;// sampler2D是取样器类型，图片纹理最终存储在该类型对象中<br>varying vec2 v_texCoord; // 接受顶点着色器传来的纹理坐标<br>void main(){<br>  float r,g,b,y,u,v,fYmul;<br>  y = texture2D(samplerY, v_texCoord).r;<br>  u = texture2D(samplerU, v_texCoord).r;<br>  v = texture2D(samplerV, v_texCoord).r;</p>
<pre><code>// YUV420P 转 RGB    </code></pre><p>  fYmul = y * 1.1643828125;<br>  r = fYmul + 1.59602734375 * v - 0.870787598;<br>  g = fYmul - 0.39176171875 * u - 0.81296875 * v + 0.52959375;<br>  b = fYmul + 2.01723046875 * u - 1.081389160375;<br>  gl_FragColor = vec4(r, g, b, 1.0);<br>}<br>创建并编译着色器，将顶点着色器和片段着色器连接到 program，并使用：</p>
<p>let vertexShader=this._compileShader(vertexShaderSource,gl.VERTEX_SHADER);// 创建并编译顶点着色器<br>let fragmentShader=this._compileShader(fragmentShaderSource,gl.FRAGMENT_SHADER);// 创建并编译片元着色器<br>let program=this._createProgram(vertexShader,fragmentShader);// 创建program并连接着色器<br>创建缓冲区，存顶点和纹理坐标（PS：缓冲区对象是WebGL系统中的一块内存区域，我们可以一次性地向缓冲区对象中填充大量的顶点数据，然后将这些数据保存在其中，供顶点着色器使用）。</p>
<p>let vertexBuffer = gl.createBuffer();<br>let vertexRectangle = new Float32Array([<br>    1.0,<br>    1.0,<br>    0.0,<br>    -1.0,<br>    1.0,<br>    0.0,<br>    1.0,<br>    -1.0,<br>    0.0,<br>    -1.0,<br>    -1.0,<br>    0.0<br>]);<br>gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);<br>// 向缓冲区写入数据<br>gl.bufferData(gl.ARRAY_BUFFER, vertexRectangle, gl.STATIC_DRAW);<br>// 找到顶点的位置<br>let vertexPositionAttribute = gl.getAttribLocation(program, ‘a_vertexPosition’);<br>// 告诉显卡从当前绑定的缓冲区中读取顶点数据<br>gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);<br>// 连接vertexPosition 变量与分配给它的缓冲区对象<br>gl.enableVertexAttribArray(vertexPositionAttribute);<br>// 声明纹理坐标<br>let textureRectangle = new Float32Array([1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0]);<br>let textureBuffer = gl.createBuffer();<br>gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);<br>gl.bufferData(gl.ARRAY_BUFFER, textureRectangle, gl.STATIC_DRAW);<br>let textureCoord = gl.getAttribLocation(program, ‘a_texturePosition’);<br>gl.vertexAttribPointer(textureCoord, 2, gl.FLOAT, false, 0, 0);<br>gl.enableVertexAttribArray(textureCoord);<br>初始化并激活纹理单元（YUV）</p>
<p>//激活指定的纹理单元<br>gl.activeTexture(gl.TEXTURE0);<br>gl.y=this._createTexture(); // 创建纹理<br>gl.uniform1i(gl.getUniformLocation(program,’samplerY’),0);//获取samplerY变量的存储位置，指定纹理单元编号0将纹理对象传递给samplerY<br>gl.activeTexture(gl.TEXTURE1);<br>gl.u=this._createTexture();<br>gl.uniform1i(gl.getUniformLocation(program,’samplerU’),1);//获取samplerU变量的存储位置，指定纹理单元编号1将纹理对象传递给samplerU<br>gl.activeTexture(gl.TEXTURE2);<br>gl.v=this._createTexture();<br>gl.uniform1i(gl.getUniformLocation(program,’samplerV’),2);//获取samplerV变量的存储位置，指定纹理单元编号2将纹理对象传递给samplerV<br>渲染绘制（PS：由于我们获取到的数据是YUV420P，那么计算方法可以参考刚才说的计算方式）。</p>
<p> // 设置清空颜色缓冲时的颜色值<br> gl.clearColor(0, 0, 0, 0);<br> // 清空缓冲<br> gl.clear(gl.COLOR_BUFFER_BIT);<br>let uOffset = width * height;<br>let vOffset = (width &gt;&gt; 1) * (height &gt;&gt; 1);<br>gl.bindTexture(gl.TEXTURE_2D, gl.y);<br>// 填充Y纹理,Y 的宽度和高度就是 width，和 height，存储的位置就是data.subarray(0, width * height)<br>gl.texImage2D(<br>    gl.TEXTURE_2D,<br>    0,<br>    gl.LUMINANCE,<br>    width,<br>    height,<br>    0,<br>    gl.LUMINANCE,<br>    gl.UNSIGNED_BYTE,<br>    data.subarray(0, uOffset)<br>);<br>gl.bindTexture(gl.TEXTURE_2D, gl.u);<br>// 填充U纹理,Y 的宽度和高度就是 width/2 和 height/2，存储的位置就是data.subarray(width * height, width/2 * height/2 + width * height)<br>gl.texImage2D(<br>    gl.TEXTURE_2D,<br>    0,<br>    gl.LUMINANCE,<br>    width &gt;&gt; 1,<br>    height &gt;&gt; 1,<br>    0,<br>    gl.LUMINANCE,<br>    gl.UNSIGNED_BYTE,<br>    data.subarray(uOffset, uOffset + vOffset)<br>);<br>gl.bindTexture(gl.TEXTURE_2D, gl.v);<br>// 填充U纹理,Y 的宽度和高度就是 width/2 和 height/2，存储的位置就是data.subarray(width/2 * height/2 + width * height, data.length)<br>gl.texImage2D(<br>    gl.TEXTURE_2D,<br>    0,<br>    gl.LUMINANCE,<br>    width &gt;&gt; 1,<br>    height &gt;&gt; 1,<br>    0,<br>    gl.LUMINANCE,<br>    gl.UNSIGNED_BYTE,<br>    data.subarray(uOffset + vOffset, data.length)<br>);<br>gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); // 绘制四个点，也就是长方形<br>上述那些步骤最终可以绘制成这张图：</p>
<p>完整代码：</p>
<p>export default class WebglScreen {<br>    constructor(canvas) {<br>        this.canvas = canvas;<br>        this.gl = canvas.getContext(‘webgl’) || canvas.getContext(‘experimental-webgl’);<br>        this._init();<br>    }<br>    _init() {<br>        let gl = this.gl;<br>        if (!gl) {<br>            console.log(‘gl not support！’);<br>            return;<br>        }<br>        // 图像预处理<br>        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);<br>        // GLSL 格式的顶点着色器代码<br>        let vertexShaderSource = <code>attribute lowp vec4 a_vertexPosition;
            attribute vec2 a_texturePosition;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = a_vertexPosition;
                v_texCoord = a_texturePosition;
            }</code>;<br>        let fragmentShaderSource = <code>precision lowp float;
            uniform sampler2D samplerY;
            uniform sampler2D samplerU;
            uniform sampler2D samplerV;
            varying vec2 v_texCoord;
            void main() {
                float r,g,b,y,u,v,fYmul;
                y = texture2D(samplerY, v_texCoord).r;
                u = texture2D(samplerU, v_texCoord).r;
                v = texture2D(samplerV, v_texCoord).r;
                fYmul = y * 1.1643828125;
                r = fYmul + 1.59602734375 * v - 0.870787598;
                g = fYmul - 0.39176171875 * u - 0.81296875 * v + 0.52959375;
                b = fYmul + 2.01723046875 * u - 1.081389160375;
                gl_FragColor = vec4(r, g, b, 1.0);
            }</code>;<br>        let vertexShader = this._compileShader(vertexShaderSource, gl.VERTEX_SHADER);<br>        let fragmentShader = this._compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);<br>        let program = this._createProgram(vertexShader, fragmentShader);<br>        this._initVertexBuffers(program);<br>        // 激活指定的纹理单元<br>        gl.activeTexture(gl.TEXTURE0);<br>        gl.y = this._createTexture();<br>        gl.uniform1i(gl.getUniformLocation(program, ‘samplerY’), 0);<br>        gl.activeTexture(gl.TEXTURE1);<br>        gl.u = this._createTexture();<br>        gl.uniform1i(gl.getUniformLocation(program, ‘samplerU’), 1);<br>        gl.activeTexture(gl.TEXTURE2);<br>        gl.v = this._createTexture();<br>        gl.uniform1i(gl.getUniformLocation(program, ‘samplerV’), 2);<br>    }<br>    /**<br>     * 初始化顶点 buffer<br>     * @param {glProgram} program 程序<br>     <em>/<br>    _initVertexBuffers(program) {<br>        let gl = this.gl;<br>        let vertexBuffer = gl.createBuffer();<br>        let vertexRectangle = new Float32Array([<br>            1.0,<br>            1.0,<br>            0.0,<br>            -1.0,<br>            1.0,<br>            0.0,<br>            1.0,<br>            -1.0,<br>            0.0,<br>            -1.0,<br>            -1.0,<br>            0.0<br>        ]);<br>        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);<br>        // 向缓冲区写入数据<br>        gl.bufferData(gl.ARRAY_BUFFER, vertexRectangle, gl.STATIC_DRAW);<br>        // 找到顶点的位置<br>        let vertexPositionAttribute = gl.getAttribLocation(program, ‘a_vertexPosition’);<br>        // 告诉显卡从当前绑定的缓冲区中读取顶点数据<br>        gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);<br>        // 连接vertexPosition 变量与分配给它的缓冲区对象<br>        gl.enableVertexAttribArray(vertexPositionAttribute);<br>        let textureRectangle = new Float32Array([1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0]);<br>        let textureBuffer = gl.createBuffer();<br>        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);<br>        gl.bufferData(gl.ARRAY_BUFFER, textureRectangle, gl.STATIC_DRAW);<br>        let textureCoord = gl.getAttribLocation(program, ‘a_texturePosition’);<br>        gl.vertexAttribPointer(textureCoord, 2, gl.FLOAT, false, 0, 0);<br>        gl.enableVertexAttribArray(textureCoord);<br>    }<br>    /*</em><br>     * 创建并编译一个着色器<br>     * @param {string} shaderSource GLSL 格式的着色器代码<br>     * @param {number} shaderType 着色器类型, VERTEX_SHADER 或 FRAGMENT_SHADER。<br>     * @return {glShader} 着色器。<br>     <em>/<br>    _compileShader(shaderSource, shaderType) {<br>        // 创建着色器程序<br>        let shader = this.gl.createShader(shaderType);<br>        // 设置着色器的源码<br>        this.gl.shaderSource(shader, shaderSource);<br>        // 编译着色器<br>        this.gl.compileShader(shader);<br>        const success = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);<br>        if (!success) {<br>            let err = this.gl.getShaderInfoLog(shader);<br>            this.gl.deleteShader(shader);<br>            console.error(‘could not compile shader’, err);<br>            return;<br>        }<br>        return shader;<br>    }<br>    /*</em><br>     * 从 2 个着色器中创建一个程序<br>     * @param {glShader} vertexShader 顶点着色器。<br>     * @param {glShader} fragmentShader 片断着色器。<br>     * @return {glProgram} 程序<br>     <em>/<br>    _createProgram(vertexShader, fragmentShader) {<br>        const gl = this.gl;<br>        let program = gl.createProgram();<br>        // 附上着色器<br>        gl.attachShader(program, vertexShader);<br>        gl.attachShader(program, fragmentShader);<br>        gl.linkProgram(program);<br>        // 将 WebGLProgram 对象添加到当前的渲染状态中<br>        gl.useProgram(program);<br>        const success = this.gl.getProgramParameter(program, this.gl.LINK_STATUS);<br>        if (!success) {<br>            console.err(‘program fail to link’ + this.gl.getShaderInfoLog(program));<br>            return;<br>        }<br>        return program;<br>    }<br>    /*</em><br>     * 设置纹理<br>     <em>/<br>    _createTexture(filter = this.gl.LINEAR) {<br>        let gl = this.gl;<br>        let t = gl.createTexture();<br>        // 将给定的 glTexture 绑定到目标（绑定点<br>        gl.bindTexture(gl.TEXTURE_2D, t);<br>        // 纹理包装 参考<a href="https://github.com/fem-d/webGL/blob/master/blog/WebGL基础学习篇（Lesson%207）.md" target="_blank" rel="noopener">https://github.com/fem-d/webGL/blob/master/blog/WebGL基础学习篇（Lesson%207）.md</a> -&gt; Texture wrapping<br>        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);<br>        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);<br>        // 设置纹理过滤方式<br>        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);<br>        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);<br>        return t;<br>    }<br>    /*</em><br>     * 渲染图片出来<br>     * @param {number} width 宽度<br>     * @param {number} height 高度<br>     <em>/<br>    renderImg(width, height, data) {<br>        let gl = this.gl;<br>        // 设置视口，即指定从标准设备到窗口坐标的x、y仿射变换<br>        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);<br>        // 设置清空颜色缓冲时的颜色值<br>        gl.clearColor(0, 0, 0, 0);<br>        // 清空缓冲<br>        gl.clear(gl.COLOR_BUFFER_BIT);<br>        let uOffset = width * height;<br>        let vOffset = (width &gt;&gt; 1) * (height &gt;&gt; 1);<br>        gl.bindTexture(gl.TEXTURE_2D, gl.y);<br>        // 填充纹理<br>        gl.texImage2D(<br>            gl.TEXTURE_2D,<br>            0,<br>            gl.LUMINANCE,<br>            width,<br>            height,<br>            0,<br>            gl.LUMINANCE,<br>            gl.UNSIGNED_BYTE,<br>            data.subarray(0, uOffset)<br>        );<br>        gl.bindTexture(gl.TEXTURE_2D, gl.u);<br>        gl.texImage2D(<br>            gl.TEXTURE_2D,<br>            0,<br>            gl.LUMINANCE,<br>            width &gt;&gt; 1,<br>            height &gt;&gt; 1,<br>            0,<br>            gl.LUMINANCE,<br>            gl.UNSIGNED_BYTE,<br>            data.subarray(uOffset, uOffset + vOffset)<br>        );<br>        gl.bindTexture(gl.TEXTURE_2D, gl.v);<br>        gl.texImage2D(<br>            gl.TEXTURE_2D,<br>            0,<br>            gl.LUMINANCE,<br>            width &gt;&gt; 1,<br>            height &gt;&gt; 1,<br>            0,<br>            gl.LUMINANCE,<br>            gl.UNSIGNED_BYTE,<br>            data.subarray(uOffset + vOffset, data.length)<br>        );<br>        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);<br>    }<br>    /*</em><br>     * 根据重新设置 canvas 大小<br>     * @param {number} width 宽度<br>     * @param {number} height 高度<br>     * @param {number} maxWidth 最大宽度<br>     */<br>    setSize(width, height, maxWidth) {<br>        let canvasWidth = Math.min(maxWidth, width);<br>        this.canvas.width = canvasWidth;<br>        this.canvas.height = canvasWidth * height / width;<br>    }<br>    destroy() {<br>        const {<br>            gl<br>        } = this;<br>        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);<br>    }<br>}<br>最后我们来看下效果图：</p>
<p>遇到的问题<br>在实际开发过程中，我们测试一些直播流，有时候渲染的时候图像显示是正常的，但是颜色会偏绿，经研究发现，直播流的不同主播的视频宽度是会不一样，比如在主播在 pk 的时候宽度368，热门主播宽度会到 720，小主播宽度是 540，而宽度为 540 的会显示偏绿，具体原因是 webgl 会经过预处理，默认会将以下值设置为 4：</p>
<p>// 图像预处理<br>gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);<br>这样默认设置会每行 4 个字节 4 个字节处理，而 Y分量每行的宽度是 540，是 4 的倍数，字节对齐了，所以图像能够正常显示，而 U，V 分量宽度是 540 / 2 = 270，270 不是4 的倍数，字节非对齐，因此色素就会显示偏绿。目前有两种方法可以解决这个问题：</p>
<p>第一个是直接让 webgl 每行 1 个字节 1 个字节处理（对性能有影响）：</p>
<p>// 图像预处理<br>gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);<br>第二个是让获取到的图像的宽度是 8 的倍数，这样就能做到 YUV 字节对齐，就不会显示绿屏，但是不建议这样做， 转的时候CPU占用极大，建议采取第一个方案。</p>
<p>参考文章<br>图像视频编码和FFmpeg(2)——YUV格式介绍和应用 - eustoma - 博客园<br>YUV pixel formats<br><a href="https://wiki.videolan.org/YUV/" target="_blank" rel="noopener">https://wiki.videolan.org/YUV/</a><br>使用 8 位 YUV 格式的视频呈现 | Microsoft Docs?redirectedfrom=MSDN)<br>IOS 视频格式之YUV - 简书<br>图解WebGL&amp;Three.js工作原理 - cnwander - 博客园</p>
<p>————-本文结束感谢您的阅读————-<br>本文标题:IVWEB 玩转 WASM 系列-WEBGL YUV渲染图像实践</p>
<p>文章作者:shenzekun</p>
<p>发布时间:2019年12月14日 - 13:20</p>
<p>最后更新:2019年12月14日 - 13:21</p>
<p>原始链接:<a href="http://www.shenzekun.cn/IVWEB-玩转-WASM-系列-WEBGL-YUV渲染图像实践.html" target="_blank" rel="noopener">http://www.shenzekun.cn/IVWEB-玩转-WASM-系列-WEBGL-YUV渲染图像实践.html</a></p>
<p>许可协议: 署名-非商业性使用-禁止演绎 4.0 国际 转载请保留原文链接及作者。</p>
<p>您的支持将鼓励我继续创作！<br>赏<br>webgl<br> 页面CPU和内存占用监控可视化Chrome插件-Graph Process<br>文章目录站点概览<br>© 2019 shenzekun<br> 博客全站共 39.8k 字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">****** *******</span><br></pre></td></tr></table></figure>

<img src="img/heart.jpg">


    </div>

    
    
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:16px;">-------------本文结束<i class="fa fa-heart"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/17/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#你好呀"><span class="nav-number">1.</span> <span class="nav-text">你好呀</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="新之言"
      src="/images/touxiang1.png">
  <p class="site-author-name" itemprop="name">新之言</p>
  <div class="site-description" itemprop="description">求而不得，往往不求而得</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">新之言</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.1
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<!--   
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
 -->
</body>
</html>
